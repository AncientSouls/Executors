{"version":3,"sources":["../src/lib/item.js"],"names":["require","EventEmitter","Item","manager","name","query","data","undefined","isPrepared","isMounted","isUnmounted","_childs","childs","parents","emitter","error","event","handler","addListener","callback","Error","once","preparation","_callback","emit","Object","keys","length","c","get","prepare","child","mount","mounting","done","unmountError","mountError","newItem","_items","item","unmount","unmounted","unmounting"],"mappings":"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","file":"item.js","sourcesContent":["var { EventEmitter } = require('fbemitter');\n\n/**\n * @class\n */\nclass Item {\n  \n  /**\n   * @constructs Item\n   * @param {Manager} manager\n   * @param {string} name\n   * @param [query]\n   */\n  constructor(manager, name, query) {\n    \n    /**\n     * @type {Manager}\n     * @protected\n     */\n    this.manager = manager;\n    \n    /**\n     * @type {string}\n     * @protected\n     */\n    this.name = name;\n    \n    /**\n     * @protected\n     */\n    this.query = query;\n    \n    /**\n     * @protected\n     */\n    this.data = undefined;\n    \n    /**\n     * Should be positive, to complete the preparation.\n     * `undefined`, before preparation, `false` on preparation, `true` if current item prepared (childs still can not be prepared).\n     * @type {boolean=}\n     * @protected\n     */\n    this.isPrepared = undefined;\n    \n    /**\n     * Should be positive, to complete the mounting.\n     * `undefined`, before mounting, `false` on mounting, `true` if mounted.\n     * @type {boolean=}\n     * @protected\n     */\n    this.isMounted = undefined;\n    \n    /**\n     * Should be positive, if item fully unmounted.\n     * Some parent items still can use this item as child, but they are notified of its unmounted stage.\n     * @type {boolean=}\n     * @protected\n     */\n    this.isUnmounted = undefined;\n    \n    /**\n     * Should be empty, to complete the preparation.\n     * @type {Object}\n     * @protected\n     */\n    this._childs = {};\n    \n    /**\n     * @type {Object.<string,Item>}\n     * @protected\n     */\n    this.childs = {};\n    \n    /**\n     * @type {Object.<string,Item>}\n     * @protected\n     */\n    this.parents = {};\n    \n    /**\n     * @type {EventEmitter}\n     * @public\n     */\n    this.emitter = new EventEmitter();\n    \n    /**\n     * Last catched error.\n     * @protected\n     */\n    this.error = undefined;\n  }\n  \n  /**\n   * @param {string} event\n   * @param {function} handler\n   * @returns {Item}\n   * @example\n   * manager.get('a')\n   *   .on('prepared', (error, item, event) => item.mount(() => {\n   *     console.log('already mounted or just mounted, calls once');\n   *   }))\n   *   .on('mounted', (error, item, event) => item.remount(item.query, () => {\n   *     console.log('just remounted once');\n   *   }))\n   *   .on('remounted', (unmountError, oldItem, mountError, newItem, event) => newItem.unmount(() => {\n   *     console.log('just unmounted once');\n   *   }))\n   *   .on('unmounted', (error, item, event) => console.log('just fully unmounted, without remounting'))\n   *   .prepare((error, item) => console.log('just prepared, calls once'))\n   */\n  on(event, handler) {\n    this.emitter.addListener(event, handler);\n    return this;\n  }\n  \n  /**\n   * @param {Item~prepareCallback} [callback]\n   * @description\n   * ##### Attention! Must be overrided.\n   * Starts the pre-mount preparation actions. It includes:\n   * * Subscribe and getting `data` based on `query`.\n   * * Generate names and queries for childs.\n   * * Call {@link Item#prepareChild} for each needed child, to generate list of not prepared childs. This list will be used to prepare childs.\n   * * **Must call {@link Item#prepared} after all preparations are done.** It will complete stage `prepare` and set `true` into {@link Item#isPrepared}. Run childs preparation and only after all childs prepared, fires callback and `prepared` event.\n   * This can lead to recursion of child preparation, everything is fine, the funicular itself will deal with this.\n   * @example\n   * new Manager(\n   *   class extends Item {\n   *     preparation(callback) {\n   *       this.data = collection.get(this.query);\n   *       // May be your data is { _id: 'a', childs: { b: { _id: 'b' }, c: { _id: 'c' } } }\n   *       for (var c in this.data.childs) {\n   *         this.prepareChild(c, this.data.childs[c]);\n   *       }\n   *       this.prepared(undefined, callback);\n   *     }\n   *   }\n   * )\n   */\n  preparation(callback) {\n    throw new Error('Must be overrided.');\n  }\n  \n  /**\n   * @param {string} name\n   * @param query\n   */\n  prepareChild(name, query) {\n    this._childs[name] = query;\n  }\n  \n  /**\n   * Start sequence of loading of this data and childs queries.\n   * It will starts stage `mounting` and set `false` into {@link Item#isMounted}.\n   * @param {Item~mountCallback} [callback]\n   */\n  prepare(callback) {\n    if (this.isPrepared || this.error) {\n      if (typeof(callback) == 'function') {\n        callback(this.error, this);\n      }\n    } else if(this.isPrepared === false) {\n      this.emitter.once('prepared', callback);\n    } else {\n      this.isPrepared = false;\n      this.preparation(callback);\n    }\n  }\n  \n  /**\n   * @fires Item#prepared\n   * @param [error]\n   * @param {Item~prepareCallback} [callback]\n   */\n  prepared(error, callback) {\n    if (!this.isPrepared) {\n      var _callback = () => {\n        this.emitter.emit('prepared', this.error, this);\n        if (typeof(callback) == 'function') callback(this.error, this);\n      };\n      this.error = error;\n      this.isPrepared = true;\n      if (!this.error) {\n        if (Object.keys(this._childs).length) {\n          for (var c in this._childs) {\n            this.manager.get(c, this._childs[c]).prepare((error, child) => {\n              if (!this.error) {\n                if (error) {\n                  this.error = new Error(`Child ${c.name} returns error on preparation.`);\n                  _callback();\n                } else {\n                  delete this._childs[c];\n                  this.childs[c] = child;\n                  if (!Object.keys(this._childs).length) {\n                    _callback();\n                  }\n                }\n              }\n            });\n          }\n        } else {\n          _callback();\n        }\n      } else {\n        _callback();\n      }\n    }\n  }\n  \n  /**\n   * @callback Item~prepareCallback\n   * @param [error]\n   * @param {Item} item\n   * @param {Object} eventSubscription\n   */\n  \n  /**\n   * @param {Item~mountCallback} [callback]\n   * @description\n   * ##### Attention! Must be overrided.\n   * Make or start making some work based on prepared childs.\n   * Place link to results or status of work into {@link Item#result}\n   * * **Must call {@link Item#mounted} after done work or starting work.** It will complete stage `mounting` and set `true` into {@link Item#isMounted}.\n   * @example\n   * new Manager(\n   *   class extends Item {\n   *     mounting(callback) {\n   *       this.result = this.data + this.data;\n   *       this.mounted(undefined, callback);\n   *     }\n   *   }\n   * )\n   */\n  mounting(callback) {\n    throw new Error('Must be overrided.');\n  }\n  \n  /**\n   * @param {Item} child\n   * @param {Item~mountCallback} [callback]\n   */\n  mountChild(child, callback) {\n    if (child.isMounted === false) {\n      if (typeof(callback) == 'function') callback();\n    } else {\n      child.mount(callback);\n    }\n  }\n  \n  /**\n   * Start sequence of needed actions for run, start, mount, execute and so on...\n   * It will starts stage `mounting` and set `false` into {@link Item#isMounted}.\n   * @param {Item~mountCallback} [callback]\n   */\n  mount(callback) {\n    if (!this.isPrepared) throw new Error('Not prepared item can not be mount.');\n    if (this.isMounted || this.error) {\n      if (typeof(callback) == 'function') {\n        callback(undefined, this);\n      }\n    } else if(this.isMounted === false) {\n      this.emitter.once('mounted', callback);\n    } else {\n      this.isMounted = false;\n      this.mounting(callback);\n    }\n  }\n  \n  /**\n   * @fires Item#mounted\n   * @param [error]\n   * @param {Item~mountCallback} [callback]\n   */\n  mounted(error, callback) {\n    if (!this.isMounted) {\n      this.isMounted = true;\n      this.error = error;\n      this.emitter.emit('mounted', error, this);\n      if (typeof(callback) == 'function') {\n        callback(error, this);\n      }\n    }\n  }\n  \n  /**\n   * @callback Item~mountCallback\n   * @param [error]\n   * @param {Item} item\n   * @param {Object} eventSubscription\n   */\n  \n  /**\n   * @fires Item#remounted\n   * @param query\n   * @param {Item~remountCallback} [callback]\n   * @description\n   * Mount new active item with equal name any may be other query, and then unmount current item.\n   * > This can be used at the time of changing the data, for remounting this and its dependent items.\n   * @example\n   * item.remount(item.query, (unmountError, oldItem, mountError, oldItem) => {});\n   */\n  remount(query, callback) {\n    if (this.isMounted && typeof(this.isUnmounted) != 'boolean') {\n      var done = (unmountError, mountError, newItem) => {\n        this.emitter.emit('remounted', unmountError, this, mountError, newItem);\n        if (typeof(callback) == 'function') {\n          callback(unmountError, this, mountError, newItem);\n        }\n      };\n      delete this.manager._items[this.name];\n      this.manager.get(this.name, query).prepare((error, item) => {\n        if (error) done(undefined, error, item);\n        else {\n          item.mount((error, item) => {\n            if (error) done(undefined, error, item);\n            else {\n              this.unmount((error) => {\n                done(error, undefined, item);\n              });\n            }\n          });\n        }\n      });\n    } else throw new Error('You can not remount not mounted or unmounted item.');\n  }\n  \n  /**\n   * @callback Item~remountCallback\n   * @param [unmountError] - only if there is not mountError\n   * @param {oldItem} oldItem\n   * @param [mountError] - only if there is not unmountError\n   * @param {oldItem} newItem\n   * @param {Object} eventSubscription\n   */\n  \n  /**\n   * @param {Item~unmountCallback} [callback]\n   * @description\n   * ##### Attention! Must be overrided.\n   * Cancel all or stop making some work started in {@link Item#mount}.\n   * * **Must call {@link Item#unmounted} after all.** It will complete stage `unmunting` and set `true` into {@link Item#isUnmounted}.\n   * @example\n   * new Manager(\n   *   class extends Item {\n   *     unmounting(callback) {\n   *       for (var c in this.childs) {\n   *         this.childs[c].unmount();\n   *       }\n   *       this.unmounted(undefined, callback);\n   *     }\n   *   }\n   * )\n   */\n  unmounting(callback) {\n    for (var c in this.childs) {\n      this.childs[c].unmount();\n    }\n    this.unmounted(undefined, callback);\n  }\n  \n  /**\n   * Start sequence of needed actions forForget, stop, turn off and so on......\n   * It will starts stage `mounting` and set `false` into {@link Item#isMounted}.\n   * @param {Item~mountCallback} [callback]\n   */\n  unmount(callback) {\n    if (!this.isMounted) throw new Error('Not mounted item can not be unmount.');\n    if (this.isUnmounted || this.error) {\n      if (typeof(callback) == 'function') {\n        callback(undefined, this);\n      }\n    } else if(this.isUnmounted === false) {\n      if (typeof(callback) == 'function') {\n        this.emitter.once('unmounted', callback);\n      }\n    } else {\n      if (Object.keys(this.parents).length) {\n        if (typeof(callback) == 'function') {\n          callback(undefined, this);\n        }\n      } else {\n        this.isUnmounted = false;\n        this.unmounting(callback);\n      }\n    }\n  }\n  \n  /**\n   * @fires Item#unmounted\n   * @param [error]\n   * @param {Item~unmountCallback} [callback]\n   */\n  unmounted(error, callback) {\n    if (!this.isUnmounted) {\n      this.isUnmounted = true;\n      this.error = error;\n      if (this.manager._items[this.name] && this.manager._items[this.name] == this) {\n        delete this.manager._items[this.name];\n      }\n      this.emitter.emit('unmounted', error, this);\n      if (typeof(callback) == 'function') {\n        callback(error, this);\n      }\n    }\n  }\n  \n  /**\n   * @callback Item~unmountCallback\n   * @param [error]\n   * @param {Item} item\n   * @param {Object} eventSubscription\n   */\n}\n\nexport default Item;"]}