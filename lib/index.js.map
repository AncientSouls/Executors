{"version":3,"sources":["../src/lib/index.js"],"names":["counter","Parent","name","item","Item","data","index","childs","parents","getResult","get","child","isItem","Error"],"mappings":"w7BAAA,GAAIA,SAAU,CAAd,CAEA;;GAGA,QAASC,OAAT,CAAgBC,IAAhB,CAAsBC,IAAtB,CAA4B,CAC1B;;;;KAKA,KAAKD,IAAL,CAAYA,IAAZ,CAEA;;;;KAKA,KAAKC,IAAL,CAAYA,IACb,CAED;;;;;;;;;;;;;;;;;;;;;;;;;MA0BMC,K,YAEJ;;;KAIA,cAAYC,IAAZ,CAAkB,4BAEhB;;;;OAKA,KAAKC,KAAL,CAAaN,SAAb,CAEA;;;;OAKA,KAAKO,MAAL,CAAc,EAAd,CAEA;;;;OAKA,KAAKC,OAAL,CAAe,EAAf,CAEA;;;;OAKA,KAAKH,IAAL,CAAYA,IAAZ,CAEA;;;OAIA,KAAKI,SAAL,CAEA;;;OAIA,KAAKC,GAEN,CAED;;;;sDAKIR,I,CAAMS,K,CAAO,CACf,GAAI,CAACC,OAAOD,KAAP,CAAL,CAAoB,KAAM,IAAIE,MAAJ,UAAmBF,KAAnB,6BAAN,CACpB,GAAI,MAAOT,KAAP,EAAgB,QAApB,CAA8B,CAC5B,KAAKK,MAAL,CAAYL,IAAZ,EAAoBS,KAApB,CACAA,MAAMH,OAAN,CAAc,KAAKF,KAAnB,EAA4B,GAAIL,OAAJ,CAAWC,IAAX,CAAiB,IAAjB,CAC7B,CAHD,IAGO,CACLS,MAAMH,OAAN,CAAc,KAAKF,KAAnB,EAA4B,GAAIL,OAAJ,CAAW,IAAX,CAAiB,IAAjB,CAC7B,CACF,CAED;;;;yCAKMU,K,CAAO,CACX,GAAI,CAACC,OAAOD,KAAP,CAAL,CAAoB,KAAM,IAAIE,MAAJ,UAAmBF,KAAnB,6BAAN,CACpB,MAAOA,OAAMH,OAAN,CAAc,KAAKF,KAAnB,CACR,CAED;;0CAGQ,CACN,KAAM,IAAIO,MAAJ,CAAU,iCAAV,CACP,CAED;;8CAGU,CACR,KAAM,IAAIA,MAAJ,CAAU,mCAAV,CACP,CAED;;kDAGY,CAAE,MAAO,OAAO,MAAKJ,SAAZ,EAA0B,UAAa,C,mBAC7D,CAED;;;;;;GAQA;;;;GAMA;;;;;;;GAQA,QAASG,OAAT,CAAgBT,IAAhB,CAAsB,CACpB,MAAO,OAAOA,KAAP,mCAAOA,IAAP,IAAgB,QAAhB,EAA4BA,eAAgBC,KACpD,E,QAGCA,I,CAAAA,I,SACAQ,M,CAAAA,M","file":"index.js","sourcesContent":["var counter = 1;\n\n/**\n * @class\n */\nfunction Parent(name, item) {\n  /**\n   * Unique index of each item.\n   * @type {Index|null}\n   * @protected\n   */\n  this.name = name;\n  \n  /**\n   * Unique index of each item.\n   * @type {Index}\n   * @protected\n   */\n  this.item = item;\n}\n\n/**\n * @class\n * @description\n * Must be extended with custom logic of get and mount/unmount.\n * @example\n * import { Item as ProtoItem } from 'ancient-funicular';\n * class Item extends ProtoItem {\n *   mount() {\n *     if (this.isMounted()) return Promise.resolve(this);\n *     return new Promise((resolve) => {\n *       this.getResult = () => this.data;\n *       resolve(this);\n *     });\n *   }\n *   unmount() {\n *     if (!this.isMounted()) return Promise.resolve(this);\n *     return new Promise((resolve) => {\n *       delete this.getResult;\n *       resolve(this);\n *     });\n *   }\n *   get() {\n *     return new Promise((resolve) => { resolve(new Item('data')); });\n *   }\n * }\n */\nclass Item {\n  \n  /**\n   * @constructs Item\n   * @param {*} data\n   */\n  constructor(data) {\n    \n    /**\n     * Unique index of each item.\n     * @type {Index}\n     * @protected\n     */\n    this.index = counter++;\n    \n    /**\n     * A items connected to this item when moving away from the root. Sorted by local names.\n     * @type {Object.<Id,Item>}\n     * @protected\n     */\n    this.childs = {};\n    \n    /**\n     * The converse notion of a childs. Sorted by parents indexes.\n     * @type {Object.<Index,Parent>}\n     * @protected\n     */\n    this.parents = {};\n    \n    /**\n     * Interim results.\n     * @type {*}\n     * @protected\n     */\n    this.data = data;\n    \n    /**\n     * Method for getting results.\n     * @type {Item~getResult}\n     */\n    this.getResult;\n    \n    /**\n     * Method for getting item by query.\n     * @type {Item~get}\n     */\n    this.get;\n    \n  }\n  \n  /**\n   * Add `child` item as child to this by pseudo `name`.\n   * Add this item as parent to `child` item.\n   * @param {Item} child\n   */\n  set(name, child) {\n    if (!isItem(child)) throw new Error(`child ${child} must be a Item instance.`);\n    if (typeof(name) == 'string') {\n      this.childs[name] = child;\n      child.parents[this.index] = new Parent(name, this);\n    } else {\n      child.parents[this.index] = new Parent(null, this);\n    }\n  }\n  \n  /**\n   * Remove this item from parents of `child` item.\n   * But not remove `child` item from childs pf thos .\n   * @param {Item} child\n   */\n  unset(child) {\n    if (!isItem(child)) throw new Error(`child ${child} must be a Item instance.`);\n    delete child.parents[this.index];\n  }\n  \n  /**\n   * @return {Promise} - Resolve fully filled and mounted item, with .\n   */\n  mount() {\n    throw new Error('Method mount must be overrided.');\n  }\n  \n  /**\n   * @return {Promise} - Resolve cleared and stopped item.\n   */\n  unmount() {\n    throw new Error('Method unmount must be overrided.');\n  }\n  \n  /**\n   * @return {boolean}\n   */\n  isMounted() { return typeof(this.getResult) == 'function'; }\n};\n\n/**\n * Method for getting item by query.\n * Must returns Promise resolves already mounted {@link Item} instance by query.\n * @callback Item~get\n * @param {*} [query]\n * @return {Promise}\n */\n\n/**\n * Must be setted in mounted item. Must be unsetted if item is unmounted.\n * @callback Item~getResult\n * @return {*}\n */\n\n/**\n * @param {Item} item\n * @return {boolean}\n * @example\n * import { isItem, Item } from 'ancient-funicular';\n * isItem(new Item()); // true\n * isItem({}); // false\n */\nfunction isItem(item) {\n  return typeof(item) == 'object' && item instanceof Item;\n};\n\nexport {\n  Item,\n  isItem,\n};"]}