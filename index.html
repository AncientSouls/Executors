<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Home - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Item.html">Item</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#_childPrepared">_childPrepared</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#_childReplaced">_childReplaced</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#_registerChild">_registerChild</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#childReplaced">childReplaced</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#childUnmounted">childUnmounted</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#forceUnmount">forceUnmount</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#mount">mount</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#mounted">mounted</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#mounting">mounting</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#parentUnmounted">parentUnmounted</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#preparation">preparation</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#prepare">prepare</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#prepareChild">prepareChild</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#prepared">prepared</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#replace">replace</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#shouldMount">shouldMount</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#shouldUnmount">shouldUnmount</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#unmount">unmount</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#unmounted">unmounted</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Item.html#unmounting">unmounting</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Manager.html">Manager</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Manager.html#get">get</a></span></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-ancient-funicular.html">ancient-funicular</a></span></li><li class="nav-heading">Events</li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Item.html#event:mounted">mounted</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Item.html#event:prepared">prepared</a></span></li><li class="nav-heading"><span class="nav-item-type type-event">E</span><span class="nav-item-name"><a href="Item.html#event:replaced">replaced</a></span></li>
</nav>

<div id="main">
    

    



    









    


    <section class="readme">
        <article><h1>Funicular</h1><blockquote>
<p>3.0.0</p>
</blockquote>
<hr>
<p><a href="https://badge.fury.io/js/ancient-funicular"><img src="https://badge.fury.io/js/ancient-funicular.svg" alt="npm version"></a>
<a href="https://gitter.im/AncientSouls/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/AncientSouls/Lobby"></a></p>
<p>Just async mounting, updating and unmounting hierarchical items.</p>
<h2>Install</h2><pre class="prettyprint source lang-bash"><code>npm install --save ancient-funicular</code></pre><h2>Why</h2><p>There are systems for managing hierarchies and performing items in hierarchies, such as React.
However, it works synchronously, children do not affect their parents, it is difficult to use for custom logic.</p>
<p><strong>Funicular</strong> contains basic asynchronous constructs for managing mountable, unmountable, changeable, replaceable, hierarchies of abstract items.</p>
<p>It does not work out of the box, it must be extented for your own needs.</p>
<h2>Facts</h2><h3>Manager</h3><p>Instance of class <code>Manager</code>.</p>
<p>The namespace for the unique items.</p>
<p>Creates or return already created active items.</p>
<p>Each item can be created only with the help of <code>manager.get</code>.</p>
<h3>Item</h3><p>Instance of class <code>Item</code>.</p>
<p>Must be extented for your own needs.</p>
<p>Must be sended into <code>Manager</code> class on it construct.</p>
<p>Provide all needed methods for control one item.</p>
<p>Some methods of this class marked as <strong>safe</strong> perform the service function and are designed to be used by you in from anywhere.</p>
<p>Some methods of this class marked as <strong>can override</strong> or <strong>must override</strong> must or can be overridden.</p>
<p>Each item can have many children on which it depends, and many parents who depend on it.</p>
<h5>Childs</h5><p>Childs are stored in <code>item.childs</code> object by local names.</p>
<p>The item fully gets childs when item item is fully prepared, and has state <code>item.isPrepared == true</code>.</p>
<p>Childs are load and prepar—É automatically immediately after the code of the <code>item.preporation</code> method is executed and <code>this.prepared(error)</code> is called.</p>
<blockquote>
<p>Childs can not be  resetted or deleted from <code>item.childs</code> by the funicular logic.</p>
</blockquote>
<p>If child has a replacement, his parents calls must ovverride method <code>item.childReplaced(localName, oldChild, newChild)</code>. This can lead to different consequences.</p>
<p>You must describe this method, for example, so that it replace parent and unmount old parent if in your own logic parents is dependent on the actuality of the childs:</p>
<pre class="prettyprint source lang-js"><code>class CustomItem extends Item {
  childReplaced(localName, oldChild, newChild) {
    this.replace(this.name, this.query, this.data).mount((error, item) => {
      this.unmount();
    });
  }
}</code></pre><p>###### </p>
<h5>Parents</h5><p>Parents are stored in <code>item.parents</code> object by unique number <code>item.index</code> of each parent.</p>
<p>Parents can appear only after the beginning of preparation, when has state <code>item.isPrepared == false</code>.</p>
<p>Parents appear after another <code>item</code> are prepared and has state <code>item.isPrepared == true</code>. Then in the process of registering children, he will record himself as a parent to each of his children.</p>
<blockquote>
<p>Parents change from time to time. When the parent is completely unmounted, it removes himself from the list of parents of his childs.</p>
</blockquote>
<p>You can specify your handler for the child when the parent is unmounted.</p>
<pre class="prettyprint source lang-js"><code>class CustomItem extends Item {
  parentUnmounted(parent) {
    this.unmount();
  }
}</code></pre><p>By default, the child makes an attempt to unmount. By default, child will be unmounted only if it does not have <code>item.parents</code>.</p>
<blockquote>
<blockquote>
<p>To answer the question, will unmount work  <code>item.unmount</code> corresponds to the overridden method <code>item.shouldUnmount</code>.</p>
</blockquote>
</blockquote>
<pre class="prettyprint source lang-js"><code>class CustomItem extends Item {
  shouldUnmount(callback) {
    if (Object.keys(this.parents).length) {
      if (callback) callback();
    } else {
      this.forceUnmount(callback);
    }
  }
}</code></pre><h5>Active</h5><p>An item is considered active when:</p>
<ul>
<li><code>item</code> exists in <code>manager._items[item.index]</code></li>
<li><code>item</code> has <code>item.isReplaced</code> and <code>item.isUnmounted</code> are equal <code>undefined</code></li>
</ul>
<p>An item is considered not active when:</p>
<ul>
<li><code>item</code> has <code>item.isUnmounted</code> is equal <code>true</code></li>
<li><code>item</code> has <code>item.isReplaced</code> is equal <code>true</code> and <code>item.replacedTo</code> contains next item. It may also not be active, to get the last active, use the <code>item.getActive()</code></li>
</ul>
<h4>Lifecycle of item</h4><h5>Construct</h5><p>Occurs when <code>manager.get</code> does not find an active item.</p>
<blockquote>
<p>By idea should not be overridden, but you can experiment)</p>
</blockquote>
<p>This item already has 4 states:</p>
<pre class="prettyprint source lang-js"><code>item.isPrepared; // undefined
item.isMounted; // undefined
item.isUnmounted; // undefined
item.isReplaced; // undefined</code></pre><h5>Prepare</h5><p>It is provoked by calling the <code>item.prepare(callback)</code> method.</p>
<blockquote>
<p>Preparation can already be performing or be performed. Calling this method does not mean that the preparation will be execute now, it's just a thread to return the prepared item into callback, when it did prepared.</p>
</blockquote>
<p>It symbolizes <code>this.data</code> loading for this item, as well as preparing its child items.</p>
<p>If the method is called the first time, it will set the state <code>item.isPrepared = false</code> and call must override method <code>item.preparation</code>.</p>
<p>When the preparation is completed, and you call <code>this.prepared(error)</code> method, the state will be set <code>item.isPrepared = true</code> and the children's <code>item.prepare</code> is called.</p>
<p>If you call <code>item.prepare</code> between <code>item.isPrepared</code> <code>true</code> and <code>false</code>, callback will be added to the <code>prepared</code> event handler.</p>
<p>When the preparation of one item is completed, the <code>prepared</code> event is called.</p>
<pre class="prettyprint source lang-js"><code>item.emitter.once('prepared', (error, item) => {});</code></pre><p>If you call the method <code>item.prepare</code> when state <code>item.isPrepared == true</code>, the callback will be called immediately, since the item is already prepared.</p>
<blockquote>
<p>One item can not be prepared several times.</p>
</blockquote>
<h6>Recursion solution</h6><p>If your hierarchies contain recursions at this stage, you do not need to worry about this. When childs start to prepare, the parent will already be marked as <code>item.isPrepared == true</code> and there will be no re-preparation. </p>
<h5>Mount</h5><p>It is provoked by calling the <code>item.mount(callback)</code> method.</p>
<blockquote>
<p>Mounting can already be performing or be performed. Calling this method does not mean that the mount will be execute now, it's just a thread to return the mounted item into callback, when it did mounted.</p>
</blockquote>
<p>It symbolizes the execute/run/eval/start/mount in your logic of loaded <code>this.data</code>.</p>
<p>If the item is not yet prepared at the time of the call to <code>item.mount</code>, the preparation will be done automatically. This means that you can immediately call the <code>item.mount</code> without thinking about the preparation.</p>
<p>If the method is called the first time, it will set the state <code>item.isMounted = false</code> and call must override method <code>item.mounting</code>.</p>
<p>When the mounting is completed, and you call <code>this.mounted(error)</code> method, the state will be set <code>item.isMounted = true</code>.</p>
<p>Unlike preparation, you decide how and when childs will be mounted.</p>
<p>When the mounting is completed, and you call <code>this.mounted(error)</code> method, the state will be set <code>item.isMounted = true</code>.</p>
<p>You must ovveride <code>item.mounting</code> method. For example:</p>
<pre class="prettyprint source lang-js"><code>class CustomItem extends Item {
  mounting() {
    async.each(this.childs, (child, next) => {
      child.mount(() => {
        next();
      });
    }, () => this.mounted(undefined));
  }
}</code></pre><p>If you call <code>item.mount</code> between <code>item.isMounted</code> <code>true</code> and <code>false</code>, callback will be added to the <code>mounted</code> event handler.</p>
<pre class="prettyprint source lang-js"><code>item.emitter.once('prepared', (error, item) => {});</code></pre><blockquote>
<p>One item can not be mounted several times.</p>
</blockquote>
<h6>Recursion solution</h6><p>It is recommended to consider this in your code. Unlike the preparation stage, if you call <code>item.mount</code> when the mount is already started, the callback will be called immediately, in order to avoid recursion.</p>
<p>You can override this with shouldMount:</p>
<pre class="prettyprint source lang-js"><code>class CustomItem extends Item {
  shouldMount(callback) {
    if (callback) callback(undefined, this);
  }
}</code></pre><h5>Replace</h5><p>It is provoked by calling the <code>item.replace()</code>/<code>item.replace(newItem)</code>/<code>item.replace(name)</code>/<code>item.replace(name, query)</code>/<code>item.replace(name, query, data)</code> method, that returns other active item.</p>
<p>If the item was not replaced earlier, creates a new item based on the instructions given in replace, or identical to the previous one. Marks the original <code>item.isPrepared == true</code>.</p>
<p>If the item has already been replaced, it acts identically to <code>item.getActive()</code>, returning the last active item.</p>
<p>After replace, this item can not be getted from manager. It is understood that the element gradually dies. However, they can continue to use if your code allows you to do this.</p>
<p>You must describe this method, for example, so that it replace parent and unmount old parent if in your own logic parents is dependent on the actuality of the childs:</p>
<pre class="prettyprint source lang-js"><code>class CustomItem extends Item {
  childReplaced(localName, oldChild, newChild) {
    this.replace(this.name, this.query, this.data).mount((error, item) => {
      this.unmount();
    });
  }
}</code></pre><p>After replace, fires event.</p>
<pre class="prettyprint source lang-js"><code>item.emitter.once('replaced', (error, item) => {});</code></pre><blockquote>
<p>One item can not be replaced several times.</p>
</blockquote>
<h5>Unmount</h5><p>It is provoked by calling the <code>item.unmount(callback)</code> method.</p>
<blockquote>
<p>Unmounting can already be performing or be performed. Calling this method does not mean that the unmount will be execute now, it's just a thread to return the unmounted item into callback, when it did unmounted.</p>
</blockquote>
<p>It symbolizes the destroy/stop/forget/clear/unmount in your logic.</p>
<p>If the method is called the first time, it will set the state <code>item.isUnmounted = false</code> and call can override method <code>item.unmounting</code>, which by default call <code>item.unmount</code> for childs.</p>
<p>When the <code>unmounting</code> is completed, and from it called <code>this.unmounted(error)</code> method, the state will be set <code>item.isUnmounted = true</code>.</p>
<p>You can ovveride <code>item.unmounting</code> method. For example:</p>
<pre class="prettyprint source lang-js"><code>class CustomItem extends Item {
  unmounting() {
    for (var c in this.childs) {
      delete this.childs[c].parents[this.index];
      this.parentUnmounted();
    }
    this.unmounted(undefined);
  }
}</code></pre><h2>Tests</h2><p>Tests can be started with comand <code>npm install ancient-funicular &amp;&amp; cd ./node_modules/ancient-funicular &amp;&amp; npm run compile &amp;&amp; npm test</code>. For more information lern <a href="https://github.com/AncientSouls/Funicular/blob/master/src/tests/index.js">src/tests/index.js</a>.</p>
<h2>License</h2><p>The MIT License (MIT)
Copyright (c) 2016 Ivan S Glazunov <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x69;&#118;&#x61;&#110;&#x73;&#103;&#108;&#97;&#x7a;&#117;&#110;&#x6f;&#x76;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;">&#x69;&#118;&#x61;&#110;&#x73;&#103;&#108;&#97;&#x7a;&#117;&#110;&#x6f;&#x76;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109;</a></p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p></article>
    </section>






</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Thu Jun 01 2017 16:47:47 GMT+0000 (UTC) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>